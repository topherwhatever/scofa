#' ((FUNCTION BETA)) Write Response Data in _RESP.dat format (pooled) but later to include unpooled
#'
#' @param info_list a list generated by by scofa with contextual information about the exam
#' @param datname the end of the RESP.dat filename, defaulting to {exam_code}_RESP.dat
#'
#' @return as a side effect, writes the _RESP.dat file to un/pooled directory and ....
#' @export
#'
#' @examples
#' write_respdat()
#' write_respdat(info_list = ilist, datname = "_RESP2.dat")
write_respdat <- function(info_list = info_list, datname = "_RESP.dat"){
  i_l = info_list
  i_l[["raw_dfs"]] = dir_ls(path = i_l[["rfiles_path"]],glob = glue("*{i_l[['exam_code']]}_RESP*"))
  i_l[["scored_dfs"]] = dir_ls(path = i_l[["rfiles_path"]],glob = "*SCORED_RESP*")
  resp_path <- glue('{i_l[["pool_path"]]}/{i_l[["exam_code"]]}{datname}')
  # Read the data from the files using either read.fwf or read.table, depending on the file format
  raw_list <- purrr::map(i_l[["raw_dfs"]],
                         ~read.fwf(.x,
                                   widths = c(6,rep(1:1,each=i_l[["nitms_form"]]))))
  scored_list <- purrr::map(scored_dfs,
                            ~read.table(.x,header=TRUE,sep=",",
                                        colClasses = c(PERSON = "character")))

  for (k in 1:length(i_l[["raw_dfs"]])){
    raw_list[[k]] <- read.fwf(paste0(i_l[["raw_dfs"]][k]), widths = c(6,rep(1:1,each=nitms_form)))
    scored_list[[k]] <- read.table(paste0(scored_dfs[k]),header=TRUE,sep=",",colClasses = c(PERSON = "character"))
    #any deleted items, scores will appear as "." character
    #change to numeric before merging
    scored_list[[k]][, c(2:(nitms_form+1))] <- sapply(scored_list[[k]][, c(2:(nitms_form+1))], as.numeric)
  }
  for (k in 1:length(i_l[["raw_dfs"]])) {
    colnames(raw_list[[k]]) <- as.list(colnames(scored_list[[k]]))
  }
  #rename columns of revised items for older cohorts

  # revise_itemnames <- function(raw_list = raw_list, revised_items = revised_items,i_l[["raw_dfs"]] = i_l[["raw_dfs"]]){
  item_names_df = tibble::as_tibble_col(x = paste0("X",revised_items), column_name = "oldnames")
  item_names_df[["newnames"]] <- paste0(item_names_df[["oldnames"]],"_1")

  for (k in 1:(length(i_l[["raw_dfs"]])-1)) {#skip the last element in list (current form)
    found <- match(colnames(raw_list[[k]]), item_names_df[["oldnames"]], nomatch = 0)
    colnames(raw_list[[k]])[colnames(raw_list[[k]]) %in% item_names_df[["oldnames"]]] <- item_names_df[["newnames"]][found]
  }


  for (k in 1:(length(i_l[["raw_dfs"]])-1)) {
    deletes <- ColNums_AllMissing(scored_list[[k]])
    if(length((deletes) != 0)) {raw_list[[k]] <- raw_list[[k]][-deletes]}
  }

  rdm1 <- bind_rows(ldf1,.id = "source") #identify the admin set
  rdm1[["source"]] <- as.numeric(rdm1[["source"]])
  #current cohort should always be 0 for easier identification
  rdm1 <- rdm1 %>% mutate(cohort = max(source) - source)

  # IDs should be width 6, with leading zeros if ID < 100000
  rdm1[["PERSON"]] <- add_lead(x = rdm1[["PERSON"]],width = 6)

  resp_dat_vars <- select(rdm1,"cohort","PERSON",starts_with("X"))

  write.table(resp_dat_vars, resp_path,
              sep = "",na = "*",quote = FALSE,
              row.names = FALSE,col.names = FALSE)

  #get the pooled item ID list
  items_pool <- data.frame(ID = colnames(select(rdm1,starts_with("X"))))
  items_pool[c(1)] <- stringr::str_remove(items_pool[,c(1)],"X") #remove X from ID
  items_pool <- items_pool %>% mutate(ENTRY = row_number()) #add data entry number

  #item count for control file
  i_l[["nitems"]] <- nrow(items_pool)
  #the item IDs for inclusion in control file
  itemlist_pool <- items_pool[["ID"]]

  #pooled key
  # put all the key file names in a list
  key_dfs <-dir_ls(path = i_l[["rfiles_path"]],glob = "*Domain*")

  key_list <- list() # creates a list for dataframes
  #read each key file and put it in list of dataframes
  for (k in 1:length(key_dfs)){
    key_list[[k]] <- read.table(key_dfs[k],header=TRUE,sep=",")
  }

}
